/**
 * Worker Code Generator
 *
 * Generates the main Cloudflare Worker entry point with x402 integration.
 */

import type { ServiceConfig } from '../wizard/create.js';

/**
 * Generate the main worker entry point
 */
export function generateWorkerCode(config: ServiceConfig): string {
  return `/**
 * ${config.name}
 *
 * ${config.description}
 *
 * This is an x402-powered API. Requests must include valid payment
 * to access the service.
 *
 * Generated by x402-builder
 */

import { x402Middleware, X402Config } from './x402.js';
import { handleRequest } from './handler.js';

export interface Env {
  // x402 configuration (from wrangler.toml vars)
  X402_PRICE: string;
  X402_TOKEN: string;
  X402_NETWORK: string;
  X402_RECEIVER: string;

  // Add your own environment variables here
  // MY_SECRET: string;
}

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    const url = new URL(request.url);

    // CORS preflight
    if (request.method === 'OPTIONS') {
      return handleCors();
    }

    // Health check (free)
    if (url.pathname === '/health') {
      return Response.json({ status: 'ok', service: '${config.name}' });
    }

    // Discovery document (free)
    if (url.pathname === '/.well-known/x402') {
      return serveDiscovery(env);
    }

    // Protected endpoint: ${config.endpoint}
    if (url.pathname === '${config.endpoint}') {
      // x402 payment gate
      const x402Config: X402Config = {
        priceUsd: parseFloat(env.X402_PRICE),
        token: env.X402_TOKEN as 'USDC',
        network: env.X402_NETWORK as 'base' | 'ethereum',
        receiver: env.X402_RECEIVER,
      };

      const paymentResult = await x402Middleware(request, x402Config);

      // If middleware returned a response, it's a 402 payment required
      if (paymentResult) {
        return addCorsHeaders(paymentResult);
      }

      // Payment verified! Run the actual handler
      try {
        const response = await handleRequest(request, env);
        return addCorsHeaders(response);
      } catch (error) {
        console.error('Handler error:', error);
        return addCorsHeaders(
          Response.json(
            { error: 'Internal server error' },
            { status: 500 }
          )
        );
      }
    }

    // 404 for unknown routes
    return addCorsHeaders(
      Response.json(
        { error: 'Not found', availableEndpoints: ['${config.endpoint}'] },
        { status: 404 }
      )
    );
  },
};

/**
 * Serve discovery document
 */
function serveDiscovery(env: Env): Response {
  const discovery = {
    version: 2,
    name: '${config.name}',
    description: '${config.description}',
    endpoints: [
      {
        path: '${config.endpoint}',
        method: '${config.method}',
        pricing: {
          amount: env.X402_PRICE,
          token: env.X402_TOKEN,
          network: env.X402_NETWORK,
        },
      },
    ],
    receiver: env.X402_RECEIVER,
  };

  return Response.json(discovery, {
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*',
    },
  });
}

/**
 * Handle CORS preflight
 */
function handleCors(): Response {
  return new Response(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, X-Payment, Authorization',
      'Access-Control-Max-Age': '86400',
    },
  });
}

/**
 * Add CORS headers to response
 */
function addCorsHeaders(response: Response): Response {
  const newHeaders = new Headers(response.headers);
  newHeaders.set('Access-Control-Allow-Origin', '*');
  newHeaders.set('Access-Control-Expose-Headers', 'X-Payment-Required, X-Payment-Receipt');

  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers: newHeaders,
  });
}
`;
}
