/**
 * Project Generator
 *
 * Generates a complete Cloudflare Worker project with x402 middleware.
 */

import { mkdir, writeFile } from 'fs/promises';
import { join } from 'path';
import type { ServiceConfig } from '../wizard/create.js';
import { generateWorkerCode } from './worker.js';
import { generateMiddleware } from './middleware.js';
import { generateDiscovery } from './discovery.js';

/**
 * Generate a complete x402 project
 */
export async function generateProject(config: ServiceConfig): Promise<string> {
  const projectDir = join(process.cwd(), config.name);

  // Create directory structure
  await mkdir(projectDir, { recursive: true });
  await mkdir(join(projectDir, 'src'), { recursive: true });
  await mkdir(join(projectDir, '.well-known'), { recursive: true });

  // Generate files
  await Promise.all([
    // Package.json
    writeFile(
      join(projectDir, 'package.json'),
      generatePackageJson(config)
    ),

    // TypeScript config
    writeFile(
      join(projectDir, 'tsconfig.json'),
      generateTsConfig()
    ),

    // Wrangler config
    writeFile(
      join(projectDir, 'wrangler.toml'),
      generateWranglerConfig(config)
    ),

    // Main worker entry
    writeFile(
      join(projectDir, 'src/index.ts'),
      generateWorkerCode(config)
    ),

    // x402 middleware
    writeFile(
      join(projectDir, 'src/x402.ts'),
      generateMiddleware(config)
    ),

    // Handler (user's business logic)
    writeFile(
      join(projectDir, 'src/handler.ts'),
      generateHandler(config)
    ),

    // Discovery document
    writeFile(
      join(projectDir, '.well-known/x402'),
      generateDiscovery(config)
    ),

    // README
    writeFile(
      join(projectDir, 'README.md'),
      generateReadme(config)
    ),

    // .gitignore
    writeFile(
      join(projectDir, '.gitignore'),
      generateGitignore()
    ),
  ]);

  return projectDir;
}

function generatePackageJson(config: ServiceConfig): string {
  return JSON.stringify({
    name: config.name,
    version: '0.1.0',
    description: config.description,
    type: 'module',
    scripts: {
      dev: 'wrangler dev',
      deploy: 'wrangler deploy',
      'tail': 'wrangler tail',
    },
    dependencies: {
      viem: '^2.21.0',
    },
    devDependencies: {
      '@cloudflare/workers-types': '^4.20240725.0',
      typescript: '^5.6.0',
      wrangler: '^3.0.0',
    },
  }, null, 2);
}

function generateTsConfig(): string {
  return JSON.stringify({
    compilerOptions: {
      target: 'ES2022',
      module: 'ESNext',
      moduleResolution: 'bundler',
      lib: ['ES2022'],
      types: ['@cloudflare/workers-types'],
      strict: true,
      noEmit: true,
      skipLibCheck: true,
    },
    include: ['src/**/*'],
  }, null, 2);
}

function generateWranglerConfig(config: ServiceConfig): string {
  return `# x402-powered API
# Generated by x402-builder

name = "${config.name}"
main = "src/index.ts"
compatibility_date = "2024-01-01"

[vars]
# x402 Configuration
X402_PRICE = "${config.pricing.pricePerRequest}"
X402_TOKEN = "USDC"
X402_NETWORK = "${config.pricing.network}"
X402_RECEIVER = "${config.wallet}"

# Add your secrets via wrangler:
# wrangler secret put MY_SECRET
`;
}

function generateHandler(config: ServiceConfig): string {
  // Generate handler based on service type
  switch (config.type) {
    case 'ai-inference':
      return generateAiHandler(config);
    case 'data-api':
      return generateDataHandler(config);
    case 'proxy':
      return generateProxyHandler(config);
    default:
      return generateCustomHandler(config);
  }
}

function generateAiHandler(config: ServiceConfig): string {
  return `/**
 * AI Inference Handler
 *
 * This is where your AI magic happens!
 * The x402 middleware has already verified payment before this runs.
 */

export interface GenerateRequest {
  prompt: string;
  max_tokens?: number;
  temperature?: number;
}

export interface GenerateResponse {
  result: string;
  tokens_used: number;
  model: string;
}

export async function handleRequest(
  request: Request,
  env: Env
): Promise<Response> {
  // Parse input
  const body = await request.json() as GenerateRequest;

  if (!body.prompt) {
    return Response.json(
      { error: 'Missing required field: prompt' },
      { status: 400 }
    );
  }

  // TODO: Replace with your actual AI inference logic
  // Examples:
  // - Call OpenAI API
  // - Run Cloudflare Workers AI
  // - Call your own model endpoint

  const result: GenerateResponse = {
    result: \`[Your AI response to: "\${body.prompt.slice(0, 50)}..."]\`,
    tokens_used: Math.ceil(body.prompt.length / 4),
    model: 'your-model-v1',
  };

  return Response.json(result);
}
`;
}

function generateDataHandler(config: ServiceConfig): string {
  return `/**
 * Data API Handler
 *
 * Serve your valuable data here!
 * The x402 middleware has already verified payment before this runs.
 */

export interface DataResponse {
  data: unknown;
  timestamp: string;
  source: string;
}

export async function handleRequest(
  request: Request,
  env: Env
): Promise<Response> {
  const url = new URL(request.url);

  // TODO: Replace with your actual data logic
  // Examples:
  // - Fetch from database
  // - Scrape and return content
  // - Compute analytics

  const result: DataResponse = {
    data: {
      message: 'Your premium data here',
      sample: [1, 2, 3, 4, 5],
    },
    timestamp: new Date().toISOString(),
    source: '${config.name}',
  };

  return Response.json(result);
}
`;
}

function generateProxyHandler(config: ServiceConfig): string {
  return `/**
 * Proxy Handler
 *
 * Forward requests to upstream APIs with payment gating.
 * The x402 middleware has already verified payment before this runs.
 */

// Configure your upstream API
const UPSTREAM_URL = 'https://api.example.com';
const UPSTREAM_API_KEY = ''; // Set via env var

export async function handleRequest(
  request: Request,
  env: Env
): Promise<Response> {
  const url = new URL(request.url);

  // Build upstream request
  const upstreamUrl = new URL(url.pathname, UPSTREAM_URL);
  upstreamUrl.search = url.search;

  const upstreamRequest = new Request(upstreamUrl.toString(), {
    method: request.method,
    headers: {
      ...Object.fromEntries(request.headers),
      'Authorization': \`Bearer \${env.UPSTREAM_API_KEY || UPSTREAM_API_KEY}\`,
    },
    body: request.body,
  });

  // Forward to upstream
  const response = await fetch(upstreamRequest);

  // Return upstream response
  return new Response(response.body, {
    status: response.status,
    headers: response.headers,
  });
}
`;
}

function generateCustomHandler(config: ServiceConfig): string {
  return `/**
 * Custom Handler
 *
 * Your business logic goes here!
 * The x402 middleware has already verified payment before this runs.
 */

export async function handleRequest(
  request: Request,
  env: Env
): Promise<Response> {
  // TODO: Implement your custom logic

  return Response.json({
    message: 'Hello from ${config.name}!',
    paid: true,
    timestamp: new Date().toISOString(),
  });
}
`;
}

function generateReadme(config: ServiceConfig): string {
  return `# ${config.name}

${config.description}

## x402 Payments

This API uses [x402](https://x402.org) for payment gating:

- **Price:** $${config.pricing.pricePerRequest} per request
- **Token:** ${config.pricing.token} on ${config.pricing.network}
- **Endpoint:** \`${config.method} ${config.endpoint}\`

## Development

\`\`\`bash
npm install
npm run dev
\`\`\`

## Deployment

\`\`\`bash
npm run deploy
\`\`\`

## Making Requests

Clients need an x402-compatible wallet to pay for requests:

\`\`\`bash
# Using Clara wallet
clara> wallet_pay_x402 url="https://${config.name}.your-subdomain.workers.dev${config.endpoint}"
\`\`\`

## Generated by x402-builder

Built with ❤️ using [x402-builder](https://github.com/your-org/x402-builder)
`;
}

function generateGitignore(): string {
  return `# Dependencies
node_modules/

# Build
dist/
.wrangler/

# Environment
.env
.env.local
.dev.vars

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db
`;
}
